
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>CommonMark Spec</title>
<link rel="stylesheet" href="spec.css">
<script src="https://code.jquery.com/jquery-2.2.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function() {
  $("div.example").each(function(e) {
    var t = $(this).find('code.language-markdown').text();
    $(this).find('a.dingus').click(function(f) {
      window.open('/dingus/?text=' +
        encodeURIComponent(t.replace(/→/g,"\t")));
    });
  });
  $("code.language-markdown").dblclick(function(e) { window.open('/dingus/?text=' +
      encodeURIComponent($(this).find('code').text()));
  });
});
</script>
</head>

<div class="examplenum">
<a href="#example-609">Example 609</a><a class="dingus" title="open in interactive dingus">Try It</a>
</div>
<div class="column">
<pre><code class="language-markdown">foo\
<span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span>bar
</code></pre>
</div>
<div class="column">
<pre><code class="language-html">&lt;p&gt;foo&lt;br<span class="space"> </span>/&gt;
bar&lt;/p&gt;
</code></pre>
</div>
</div>
<p>Line breaks can occur inside emphasis, links, and other constructs
that allow inline content:</p>
<div class="example" id="example-610">
<div class="examplenum">
<a href="#example-610">Example 610</a><a class="dingus" title="open in interactive dingus">Try It</a>
</div>
<div class="column">
<pre><code class="language-markdown">*foo<span class="space"> </span><span class="space"> </span>
bar*
</code></pre>
</div>
<div class="column">
<pre><code class="language-html">&lt;p&gt;&lt;em&gt;foo&lt;br<span class="space"> </span>/&gt;
bar&lt;/em&gt;&lt;/p&gt;
</code></pre>
</div>
</div>
<div class="example" id="example-611">
<div class="examplenum">
<a href="#example-611">Example 611</a><a class="dingus" title="open in interactive dingus">Try It</a>
</div>
<div class="column">
<pre><code class="language-markdown">*foo\
bar*
</code></pre>
</div>
<div class="column">
<pre><code class="language-html">&lt;p&gt;&lt;em&gt;foo&lt;br<span class="space"> </span>/&gt;
bar&lt;/em&gt;&lt;/p&gt;
</code></pre>
</div>
</div>
<p>Line breaks do not occur inside code spans</p>
<div class="example" id="example-612">
<div class="examplenum">
<a href="#example-612">Example 612</a><a class="dingus" title="open in interactive dingus">Try It</a>
</div>
<div class="column">
<pre><code class="language-markdown">`code<span class="space"> </span><span class="space"> </span>
span`
</code></pre>
</div>
<div class="column">
<pre><code class="language-html">&lt;p&gt;&lt;code&gt;code<span class="space"> </span>span&lt;/code&gt;&lt;/p&gt;
</code></pre>
</div>
</div>
<div class="example" id="example-613">
<div class="examplenum">
<a href="#example-613">Example 613</a><a class="dingus" title="open in interactive dingus">Try It</a>
</div>
<div class="column">
<pre><code class="language-markdown">`code\
span`
</code></pre>
</div>
<div class="column">
<pre><code class="language-html">&lt;p&gt;&lt;code&gt;code\<span class="space"> </span>span&lt;/code&gt;&lt;/p&gt;
</code></pre>
</div>
</div>
<p>or HTML tags:</p>
<div class="example" id="example-614">
<div class="examplenum">
<a href="#example-614">Example 614</a><a class="dingus" title="open in interactive dingus">Try It</a>
</div>
<div class="column">
<pre><code class="language-markdown">&lt;a<span class="space"> </span>href=&quot;foo<span class="space"> </span><span class="space"> </span>
bar&quot;&gt;
</code></pre>
</div>
<div class="column">
<pre><code class="language-html">&lt;p&gt;&lt;a<span class="space"> </span>href=&quot;foo<span class="space"> </span><span class="space"> </span>
bar&quot;&gt;&lt;/p&gt;
</code></pre>
</div>
</div>
<div class="example" id="example-615">
<div class="examplenum">
<a href="#example-615">Example 615</a><a class="dingus" title="open in interactive dingus">Try It</a>
</div>
<div class="column">
<pre><code class="language-markdown">&lt;a<span class="space"> </span>href=&quot;foo\
bar&quot;&gt;
</code></pre>
</div>
<div class="column">
<pre><code class="language-html">&lt;p&gt;&lt;a<span class="space"> </span>href=&quot;foo\
bar&quot;&gt;&lt;/p&gt;
</code></pre>
</div>
</div>
<p>Hard line breaks are for separating inline content within a block.
Neither syntax for hard line breaks works at the end of a paragraph or
other block element:</p>
<div class="example" id="example-616">
<div class="examplenum">
<a href="#example-616">Example 616</a><a class="dingus" title="open in interactive dingus">Try It</a>
</div>
<div class="column">
<pre><code class="language-markdown">foo\
</code></pre>
</div>
<div class="column">
<pre><code class="language-html">&lt;p&gt;foo\&lt;/p&gt;
</code></pre>
</div>
</div>
<div class="example" id="example-617">
<div class="examplenum">
<a href="#example-617">Example 617</a><a class="dingus" title="open in interactive dingus">Try It</a>
</div>
<div class="column">
<pre><code class="language-markdown">foo<span class="space"> </span><span class="space"> </span>
</code></pre>
</div>
<div class="column">
<pre><code class="language-html">&lt;p&gt;foo&lt;/p&gt;
</code></pre>
</div>
</div>
<div class="example" id="example-618">
<div class="examplenum">
<a href="#example-618">Example 618</a><a class="dingus" title="open in interactive dingus">Try It</a>
</div>
<div class="column">
<pre><code class="language-markdown">###<span class="space"> </span>foo\
</code></pre>
</div>
<div class="column">
<pre><code class="language-html">&lt;h3&gt;foo\&lt;/h3&gt;
</code></pre>
</div>
</div>
<div class="example" id="example-619">
<div class="examplenum">
<a href="#example-619">Example 619</a><a class="dingus" title="open in interactive dingus">Try It</a>
</div>
<div class="column">
<pre><code class="language-markdown">###<span class="space"> </span>foo<span class="space"> </span><span class="space"> </span>
</code></pre>
</div>
<div class="column">
<pre><code class="language-html">&lt;h3&gt;foo&lt;/h3&gt;
</code></pre>
</div>
</div>
<h2 id="soft-line-breaks" href="#soft-line-breaks" class="definition">
<span class="number">6.10</span>Soft line breaks
</h2>
<p>A regular line break (not in a code span or HTML tag) that is not
preceded by two or more spaces or a backslash is parsed as a
<a id="softbreak" href="#softbreak" class="definition">softbreak</a>.  (A softbreak may be rendered in HTML either as a
<a href="#line-ending">line ending</a> or as a space. The result will be the same in
browsers. In the examples here, a <a href="#line-ending">line ending</a> will be used.)</p>
<div class="example" id="example-620">
<div class="examplenum">
<a href="#example-620">Example 620</a><a class="dingus" title="open in interactive dingus">Try It</a>
</div>
<div class="column">
<pre><code class="language-markdown">foo
baz
</code></pre>
</div>
<div class="column">
<pre><code class="language-html">&lt;p&gt;foo
baz&lt;/p&gt;
</code></pre>
</div>
</div>
<p>Spaces at the end of the line and beginning of the next line are
removed:</p>
<div class="example" id="example-621">
<div class="examplenum">
<a href="#example-621">Example 621</a><a class="dingus" title="open in interactive dingus">Try It</a>
</div>
<div class="column">
<pre><code class="language-markdown">foo<span class="space"> </span>
<span class="space"> </span>baz
</code></pre>
</div>
<div class="column">
<pre><code class="language-html">&lt;p&gt;foo
baz&lt;/p&gt;
</code></pre>
</div>
</div>
<p>A conforming parser may render a soft line break in HTML either as a
line break or as a space.</p>
<p>A renderer may also provide an option to render soft line breaks
as hard line breaks.</p>
<h2 id="textual-content" href="#textual-content" class="definition">
<span class="number">6.11</span>Textual content
</h2>
<p>Any characters not given an interpretation by the above rules will
be parsed as plain textual content.</p>
<div class="example" id="example-622">
<div class="examplenum">
<a href="#example-622">Example 622</a><a class="dingus" title="open in interactive dingus">Try It</a>
</div>
<div class="column">
<pre><code class="language-markdown">hello<span class="space"> </span>$.;'there
</code></pre>
</div>
<div class="column">
<pre><code class="language-html">&lt;p&gt;hello<span class="space"> </span>$.;'there&lt;/p&gt;
</code></pre>
</div>
</div>
<div class="example" id="example-623">
<div class="examplenum">
<a href="#example-623">Example 623</a><a class="dingus" title="open in interactive dingus">Try It</a>
</div>
<div class="column">
<pre><code class="language-markdown">Foo<span class="space"> </span>χρῆν
</code></pre>
</div>
<div class="column">
<pre><code class="language-html">&lt;p&gt;Foo<span class="space"> </span>χρῆν&lt;/p&gt;
</code></pre>
</div>
</div>
<p>Internal spaces are preserved verbatim:</p>
<div class="example" id="example-624">
<div class="examplenum">
<a href="#example-624">Example 624</a><a class="dingus" title="open in interactive dingus">Try It</a>
</div>
<div class="column">
<pre><code class="language-markdown">Multiple<span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span>spaces
</code></pre>
</div>
<div class="column">
<pre><code class="language-html">&lt;p&gt;Multiple<span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span>spaces&lt;/p&gt;
</code></pre>
</div>
</div>
<!-- END TESTS -->
<div class="appendices">
<h1 id="appendix-a-parsing-strategy" href="#appendix-a-parsing-strategy" class="definition">
Appendix: A parsing strategy
</h1>
</div>
<p>In this appendix we describe some features of the parsing strategy
used in the CommonMark reference implementations.</p>
<h2 id="overview" href="#overview" class="definition">
Overview
</h2>
<p>Parsing has two phases:</p>
<ol>
<li>
<p>In the first phase, lines of input are consumed and the block
structure of the document—its division into paragraphs, block quotes,
list items, and so on—is constructed.  Text is assigned to these
blocks but not parsed. Link reference definitions are parsed and a
map of links is constructed.</p>
</li>
<li>
<p>In the second phase, the raw text contents of paragraphs and headings
are parsed into sequences of Markdown inline elements (strings,
code spans, links, emphasis, and so on), using the map of link
references constructed in phase 1.</p>
</li>
</ol>
<p>At each point in processing, the document is represented as a tree of
<strong>blocks</strong>.  The root of the tree is a <code>document</code> block.  The <code>document</code>
may have any number of other blocks as <strong>children</strong>.  These children
may, in turn, have other blocks as children.  The last child of a block
is normally considered <strong>open</strong>, meaning that subsequent lines of input
can alter its contents.  (Blocks that are not open are <strong>closed</strong>.)
Here, for example, is a possible document tree, with the open blocks
marked by arrows:</p>
<pre><code class="language-tree">-&gt; document
  -&gt; block_quote
       paragraph
         &quot;Lorem ipsum dolor\nsit amet.&quot;
    -&gt; list (type=bullet tight=true bullet_char=-)
         list_item
           paragraph
             &quot;Qui *quodsi iracundia*&quot;
      -&gt; list_item
        -&gt; paragraph
             &quot;aliquando id&quot;
</code></pre>
<h2 id="phase-1-block-structure" href="#phase-1-block-structure" class="definition">
Phase 1: block structure
</h2>
<p>Each line that is processed has an effect on this tree.  The line is
analyzed and, depending on its contents, the document may be altered
in one or more of the following ways:</p>
<ol>
<li>One or more open blocks may be closed.</li>
<li>One or more new blocks may be created as children of the
last open block.</li>
<li>Text may be added to the last (deepest) open block remaining
on the tree.</li>
</ol>
<p>Once a line has been incorporated into the tree in this way,
it can be discarded, so input can be read in a stream.</p>
<p>For each line, we follow this procedure:</p>
<ol>
<li>
<p>First we iterate through the open blocks, starting with the
root document, and descending through last children down to the last
open block.  Each block imposes a condition that the line must satisfy
if the block is to remain open.  For example, a block quote requires a
<code>&gt;</code> character.  A paragraph requires a non-blank line.
In this phase we may match all or just some of the open
blocks.  But we cannot close unmatched blocks yet, because we may have a
<a href="#lazy-continuation-line">lazy continuation line</a>.</p>
</li>
<li>
<p>Next, after consuming the continuation markers for existing
blocks, we look for new block starts (e.g. <code>&gt;</code> for a block quote).
If we encounter a new block start, we close any blocks unmatched
in step 1 before creating the new block as a child of the last
matched block.</p>
</li>
<li>
<p>Finally, we look at the remainder of the line (after block
markers like <code>&gt;</code>, list markers, and indentation have been consumed).
This is text that can be incorporated into the last open
block (a paragraph, code block, heading, or raw HTML).</p>
</li>
</ol>
<p>Setext headings are formed when we see a line of a paragraph
that is a <a href="#setext-heading-underline">setext heading underline</a>.</p>
<p>Reference link definitions are detected when a paragraph is closed;
the accumulated text lines are parsed to see if they begin with
one or more reference link definitions.  Any remainder becomes a
normal paragraph.</p>
<p>We can see how this works by considering how the tree above is
generated by four lines of Markdown:</p>
<pre><code class="language-markdown">&gt; Lorem ipsum dolor
sit amet.
&gt; - Qui *quodsi iracundia*
&gt; - aliquando id
</code></pre>
<p>At the outset, our document model is just</p>
<pre><code class="language-tree">-&gt; document
</code></pre>
<p>The first line of our text,</p>
<pre><code class="language-markdown">&gt; Lorem ipsum dolor
</code></pre>
<p>causes a <code>block_quote</code> block to be created as a child of our
open <code>document</code> block, and a <code>paragraph</code> block as a child of
the <code>block_quote</code>.  Then the text is added to the last open
block, the <code>paragraph</code>:</p>
<pre><code class="language-tree">-&gt; document
  -&gt; block_quote
    -&gt; paragraph
         &quot;Lorem ipsum dolor&quot;
</code></pre>
<p>The next line,</p>
<pre><code class="language-markdown">sit amet.
</code></pre>
<p>is a “lazy continuation” of the open <code>paragraph</code>, so it gets added
to the paragraph’s text:</p>
<pre><code class="language-tree">-&gt; document
  -&gt; block_quote
    -&gt; paragraph
         &quot;Lorem ipsum dolor\nsit amet.&quot;
</code></pre>
<p>The third line,</p>
<pre><code class="language-markdown">&gt; - Qui *quodsi iracundia*
</code></pre>
<p>causes the <code>paragraph</code> block to be closed, and a new <code>list</code> block
opened as a child of the <code>block_quote</code>.  A <code>list_item</code> is also
added as a child of the <code>list</code>, and a <code>paragraph</code> as a child of
the <code>list_item</code>.  The text is then added to the new <code>paragraph</code>:</p>
<pre><code class="language-tree">-&gt; document
  -&gt; block_quote
       paragraph
         &quot;Lorem ipsum dolor\nsit amet.&quot;
    -&gt; list (type=bullet tight=true bullet_char=-)
      -&gt; list_item
        -&gt; paragraph
             &quot;Qui *quodsi iracundia*&quot;
</code></pre>
<p>The fourth line,</p>
<pre><code class="language-markdown">&gt; - aliquando id
</code></pre>
<p>causes the <code>list_item</code> (and its child the <code>paragraph</code>) to be closed,
and a new <code>list_item</code> opened up as child of the <code>list</code>.  A <code>paragraph</code>
is added as a child of the new <code>list_item</code>, to contain the text.
We thus obtain the final tree:</p>
<pre><code class="language-tree">-&gt; document
  -&gt; block_quote
       paragraph
         &quot;Lorem ipsum dolor\nsit amet.&quot;
    -&gt; list (type=bullet tight=true bullet_char=-)
         list_item
           paragraph
             &quot;Qui *quodsi iracundia*&quot;
      -&gt; list_item
        -&gt; paragraph
             &quot;aliquando id&quot;
</code></pre>
<h2 id="phase-2-inline-structure" href="#phase-2-inline-structure" class="definition">
Phase 2: inline structure
</h2>
<p>Once all of the input has been parsed, all open blocks are closed.</p>
<p>We then “walk the tree,” visiting every node, and parse raw
string contents of paragraphs and headings as inlines.  At this
point we have seen all the link reference definitions, so we can
resolve reference links as we go.</p>
<pre><code class="language-tree">document
  block_quote
    paragraph
      str &quot;Lorem ipsum dolor&quot;
      softbreak
      str &quot;sit amet.&quot;
    list (type=bullet tight=true bullet_char=-)
      list_item
        paragraph
          str &quot;Qui &quot;
          emph
            str &quot;quodsi iracundia&quot;
      list_item
        paragraph
          str &quot;aliquando id&quot;
</code></pre>
<p>Notice how the <a href="#line-ending">line ending</a> in the first paragraph has
been parsed as a <code>softbreak</code>, and the asterisks in the first list item
have become an <code>emph</code>.</p>
<h3 id="an-algorithm-for-parsing-nested-emphasis-and-links" href="#an-algorithm-for-parsing-nested-emphasis-and-links" class="definition">
An algorithm for parsing nested emphasis and links
</h3>
<p>By far the trickiest part of inline parsing is handling emphasis,
strong emphasis, links, and images.  This is done using the following
algorithm.</p>
<p>When we’re parsing inlines and we hit either</p>
<ul>
<li>a run of <code>*</code> or <code>_</code> characters, or</li>
<li>a <code>[</code> or <code>![</code></li>
</ul>
<p>we insert a text node with these symbols as its literal content, and we
add a pointer to this text node to the <a id="delimiter-stack" href="#delimiter-stack" class="definition">delimiter stack</a>.</p>
<p>The <a href="#delimiter-stack">delimiter stack</a> is a doubly linked list.  Each
element contains a pointer to a text node, plus information about</p>
<ul>
<li>the type of delimiter (<code>[</code>, <code>![</code>, <code>*</code>, <code>_</code>)</li>
<li>the number of delimiters,</li>
<li>whether the delimiter is “active” (all are active to start), and</li>
<li>whether the delimiter is a potential opener, a potential closer,
or both (which depends on what sort of characters precede
and follow the delimiters).</li>
</ul>
<p>When we hit a <code>]</code> character, we call the <em>look for link or image</em>
procedure (see below).</p>
<p>When we hit the end of the input, we call the <em>process emphasis</em>
procedure (see below), with <code>stack_bottom</code> = NULL.</p>
<h4 id="-look-for-link-or-image-" href="#-look-for-link-or-image-" class="definition">
<em>look for link or image</em>
</h4>
<p>Starting at the top of the delimiter stack, we look backwards
through the stack for an opening <code>[</code> or <code>![</code> delimiter.</p>
<ul>
<li>
<p>If we don’t find one, we return a literal text node <code>]</code>.</p>
</li>
<li>
<p>If we do find one, but it’s not <em>active</em>, we remove the inactive
delimiter from the stack, and return a literal text node <code>]</code>.</p>
</li>
<li>
<p>If we find one and it’s active, then we parse ahead to see if
we have an inline link/image, reference link/image, compact reference
link/image, or shortcut reference link/image.</p>
<ul>
<li>
<p>If we don’t, then we remove the opening delimiter from the
delimiter stack and return a literal text node <code>]</code>.</p>
</li>
<li>
<p>If we do, then</p>
<ul>
<li>
<p>We return a link or image node whose children are the inlines
after the text node pointed to by the opening delimiter.</p>
</li>
<li>
<p>We run <em>process emphasis</em> on these inlines, with the <code>[</code> opener
as <code>stack_bottom</code>.</p>
</li>
<li>
<p>We remove the opening delimiter.</p>
</li>
<li>
<p>If we have a link (and not an image), we also set all
<code>[</code> delimiters before the opening delimiter to <em>inactive</em>.  (This
will prevent us from getting links within links.)</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="-process-emphasis-" href="#-process-emphasis-" class="definition">
<em>process emphasis</em>
</h4>
<p>Parameter <code>stack_bottom</code> sets a lower bound to how far we
descend in the <a href="#delimiter-stack">delimiter stack</a>.  If it is NULL, we can
go all the way to the bottom.  Otherwise, we stop before
visiting <code>stack_bottom</code>.</p>
<p>Let <code>current_position</code> point to the element on the <a href="#delimiter-stack">delimiter stack</a>
just above <code>stack_bottom</code> (or the first element if <code>stack_bottom</code>
is NULL).</p>
<p>We keep track of the <code>openers_bottom</code> for each delimiter
type (<code>*</code>, <code>_</code>).  Initialize this to <code>stack_bottom</code>.</p>
<p>Then we repeat the following until we run out of potential
closers:</p>
<ul>
<li>
<p>Move <code>current_position</code> forward in the delimiter stack (if needed)
until we find the first potential closer with delimiter <code>*</code> or <code>_</code>.
(This will be the potential closer closest
to the beginning of the input – the first one in parse order.)</p>
</li>
<li>
<p>Now, look back in the stack (staying above <code>stack_bottom</code> and
the <code>openers_bottom</code> for this delimiter type) for the
first matching potential opener (“matching” means same delimiter).</p>
</li>
<li>
<p>If one is found:</p>
<ul>
<li>
<p>Figure out whether we have emphasis or strong emphasis:
if both closer and opener spans have length &gt;= 2, we have
strong, otherwise regular.</p>
</li>
<li>
<p>Insert an emph or strong emph node accordingly, after
the text node corresponding to the opener.</p>
</li>
<li>
<p>Remove any delimiters between the opener and closer from
the delimiter stack.</p>
</li>
<li>
<p>Remove 1 (for regular emph) or 2 (for strong emph) delimiters
from the opening and closing text nodes.  If they become empty
as a result, remove them and remove the corresponding element
of the delimiter stack.  If the closing node is removed, reset
<code>current_position</code> to the next element in the stack.</p>
</li>
</ul>
</li>
<li>
<p>If none in found:</p>
<ul>
<li>
<p>Set <code>openers_bottom</code> to the element before <code>current_position</code>.
(We know that there are no openers for this kind of closer up to and
including this point, so this puts a lower bound on future searches.)</p>
</li>
<li>
<p>If the closer at <code>current_position</code> is not a potential opener,
remove it from the delimiter stack (since we know it can’t
be a closer either).</p>
</li>
<li>
<p>Advance <code>current_position</code> to the next element in the stack.</p>
</li>
</ul>
</li>
</ul>
<p>After we’re done, we remove all delimiters above <code>stack_bottom</code> from the
delimiter stack.</p>


</body>
</html>
